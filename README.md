# Микросервисный backend проект Кинотеатра

## Оглавление:
1. [Введение](#введение)
2. [Запуск](#запуск)
3. [Сервисы и описание эндпоинтов](#сервисы-и-описание-эндпоинтов)
   - [Eureka Server](#eureka-server)
   - [Config Server](#config-server)
   - [Admin Server](#admin-server)
   - [API Gateway](#api-gateway)
   - [Dictionary Service](#dictionary-service)
      - [Краткое описание](#краткое-описание)
      - [Логика](#логика)
   - [File Service](#file-service)
      - [Краткое описание](#краткое-описание-1)
      - [Логика](#логика-1)
   - [Movie Service](#movie-service)
      - [Краткое описание](#краткое-описание-2)
      - [Логика](#логика-2)
   - [Session Service](#session-service)
      - [Краткое описание](#краткое-описание-3)
      - [Логика](#логика-3)
      - [Фоновые задачи](#фоновые-задачи)
        - [Отключение доступности сеанса](#отключение-доступности-сеанса)
        - [Обновление доступности мест после проверки бронирований](#обновление-доступности-мест-после-проверки-бронирований)
   - [User Service](#user-service)
      - [Краткое описание](#краткое-описание-4)
      - [Логика](#логика-4)
      - [Фоновые задачи](#фоновые-задачи-1)
        - [Деактивация клиента](#деактивация-клиента)
        - [Удаление клиентов](#удаление-клиентов)
   - [Booking Service](#booking-service)
      - [Краткое описание](#краткое-описание-5)
      - [Логика](#логика-5)
      - [Фоновые задачи](#фоновые-задачи-2)
        - [Проверка бронирований](#проверка-бронирований)
   - [Receipt Service](#receipt-service)
      - [Краткое описание](#краткое-описание-6)
      - [Логика](#логика-6)
   - [Notification Service](#notification-service)
      - [Краткое описание](#краткое-описание-7)
      - [Логика](#логика-7)
   - [Schedule Service](#schedule-service)
      - [Краткое описание](#краткое-описание-8)
      - [Логика](#логика-8)
4. [Keycloak](#keycloak)
5. [Мониторинг](#мониторинг)
6. [Docker](#docker)

## Введение
Данный проект представляет собой мультимодульный микросервисный проект кинотеатра,
написанный на Java с использованием следующих технологий:
- **Spring Boot 3.4** (микросервисы построены с использованием Spring Cloud и Eureka)
- **Circuit Breaker**
- **Swagger**
- **PostgreSQL**
- **Flyway**
- **Keycloak**
- **Jasypt**
- **RabbitMQ**
- **Grafana Stack - Loki, Tempo и Victoria Metrics как Prometheus**

Помимо **Junit 5** для тестирования использовались также **Testcontainers**, **WireMock** м **Rest-assured**

В этом проекте есть возможность как работать с информацией о фильмах доступных для 
просмотра в кинотеатре, так и совершать заказы для бронирования билетов на сеансы и 
в последующем получать уведомления на почту о заказе. А также полноценный сервис для 
работы с пользователями

## Запуск
Минимальное программное обеспечение для запуска проекта:
- **Linux/Windows/Mac**
- **JDK 21**
- **Maven**
- **Docker**
- **Eclipse/Intellij IDEA/VSCode/VIM**

Самое первое и главное: 
```
Пройтись по всем файла мультимодульного проекта и
заменить IP адрес 0.0.0.1 на IP адрес вашего устройства (не localhost и не 127.0.0.1, т.к. иначе Victoria Metrics не 
сможет метрики собирать с /actuator/prometheus, но если они Вам не важны эти метрики, то можете и один из этих адресов 
добавить), где вы будете запускать проект
```
Узнать IP адрес вашего устройства вы можете, набрав команду, в консоли:
```
ipconfig
```
После замены IP адреса вам необходимо в консоли, находясь в корне директории мультимодульного проекта, ввести 
следующую команду, которая запустит сборку проекта, выполнение тестов и начнёт загрузку всех необходимых зависимостей:
```
mvn clean install
```

В порядке запуска сервисов Кинотеатра играют самую важную роль Eureka Server и Config Server - их надо запускать 
в первую очередь (так как во всех сервисах, кроме Eureka Server, Admin Server и API Gateway, конфигурация подтягивается 
из Config Server), а далее можно в любом порядке микросервисы запускать, но некоторые обращаются к другим 
и возможна ошибка, когда внешний сервис недоступен, поэтому лучше всего запускать микросервисы в следующем порядке:
1. Eureka Server (eureka-server)
2. Admin Server (admin-server)
3. Config Server (config-server)
4. API Gateway (api-gateway)
5. Dictionary Service (dictionary-service)
6. File Service (file-service)
7. Movie Service (movie-service) - есть запросы к Dictionary Service
8. Session Service (session-service) - есть запросы к Movie Service
9. User Service (user-service)
10. Booking Service (booking-service) - есть запросы к Session Service, User Service 
и Movie Service
11. Receipt Service (receipt-service) - есть запросы к Booking Service
12. Notification Service (notification-service)

Для запуска сервисов и их работы выбираем любой понравившийся вариант:

1. Запуск разработанных сервисов как Docker контейнеры:
   - Создаём сеть: **docker network create microservices-net**
   - Запускаем основной Docker Compose файла: **docker compose -f compose.yml up -d**
   - Получаем токен со скоупом config следующим запросом: 
      ```
      curl -X POST -d "grant_type=client_credentials&client_id=config-server&client_secret=OnzxLcAxbHYm3ZTBAMhHqVyGHkHR9beN&scope=config metrics" http://IP_адрес_вашего_устройства:9180/realms/cinema/protocol/openid-connect/token
      ```
   - Открываем файл .env в корне директории мультимодульного проекта и добавляем в переменную 
   TOKEN значение ключа "access_token" из ответа предыдущего запроса
   - Запускаем Docker Compose файл с Docker контейнерами приложений: **docker compose -f compose-docker.yml up -d**
   - Пользуемся и отправляем запросы
2. Запуск разработанных сервисов в своей локальной сети (на примере Intellij Idea Community Edition):
 - Создаём сеть: **docker network create microservices-net**
 - Запускаем основной Docker Compose файл: **docker compose -f compose.yml up -d**
 - Запускаем Docker Compose файл для разработки со стеком Grafana: **docker compose -f compose-dev.yml up -d**
 - Старт Eureka Server с передачей следующих переменных: 
   ```
   Environment Variables:
   SPRING_PROFILES_ACTIVE=dev;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Admin Server с передачей следующих переменных: 
   ```
   Environment Variables:
   SPRING_PROFILES_ACTIVE=cloud;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Config Server с передачей следующих переменных:
   ```
   Environment Variables:
   SPRING_PROFILES_ACTIVE=dev;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт API Gateway с передачей следующих переменных:
   ```
   Environment Variables:
   SPRING_PROFILES_ACTIVE=dev;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Получаем токен со скоупом config следующим запросом:
   ```
   curl -X POST -d "grant_type=client_credentials&client_id=config-server&client_secret=OnzxLcAxbHYm3ZTBAMhHqVyGHkHR9beN&scope=config" http://IP_адрес_вашего_устройства:9180/realms/cinema/protocol/openid-connect/token
   ```
 - Старт Dictionary Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт File Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
  
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Movie Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Session Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт User Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Booking Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Receipt Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DPATH_TO_FONT=./data/fonts/DejaVuSerif-Bold.ttf -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```
 - Старт Notification Service с передачей следующих переменных:
   ```
   Add VM Options:
   -DCONFIG_TOKEN=**значение ключа "access_token" из ответа запроса клиента config-server**
   
   Environment Variables:
   SPRING_PROFILES_ACTIVE=config;LOKI=http://IP_адрес_вашего_устройства:3100
   ```

## Сервисы и описание эндпоинтов
Этот проект содержит 12 сервисов и 4 модуля с библиотеками. Далее будет рассказ о 8 сервисах, с эндпоинтами которых 
происходит основное взаимодействие при работе с данным мультимодульным проектом. К ним можно обращаться как через 
**API Gateway** (**Swagger** на этом сервисе тоже доступен и можно через него отправлять запросы), так и напрямую. 
Конфигурационные файлы ко всем сервисам (кроме **Eureka Server**, **Admin Server** и **API Gateway**) подтягиваются из 
**Config Server**

### Eureka Server

Реестр, в котором микросервисы сообщают о своей доступности, а другие сервисы могут узнать, где находятся необходимые 
им ресурсы. С помощью данного сервиса также реализуется поддержка балансировки нагрузки (**Load Balancing**). Порт 
данного сервиса 8761. Для просмотра содержимого **Eureka Server** необходимо войти под пользователем с ролью **admin** в 
**Keycloak**. Посмотреть доступных начальных пользователей можно в [Keycloak](#keycloak)

### Config Server

Централизованный сервис, который предоставляет внешнюю конфигурацию для приложений в распределенной системе, такой как 
микросервисы. Порт данного сервиса 8888. Для доступа к конфигурационным файлам достаточно получение токена с помощью 
**grant_type** равному **client_credentials** и **scope** равному **config**

### Admin Server

Сервис, используемый для управления и мониторинга сервисов проекта. Данные о доступных сервисах он получает из 
**Eureka Server**. Порт данного сервиса 8039. Для просмотра содержимого **Eureka Server** необходимо войти под 
пользователем с ролью **admin** в **Keycloak**. Посмотреть доступных начальных пользователей можно в [Keycloak](#keycloak)

### API Gateway

Сервис, который отвечает за маршрутизацию запросов, т.е. к эндпоинтам других сервисов можно обращаться через него. Порт 
данного сервиса 9000

1. [Dictionary Service](#dictionary-service)
2. [File Service](#file-service)
3. [Movie Service](#movie-service)
4. [Session Service](#session-service)
5. [User Service](#user-service)
6. [Booking Service](#booking-service)
7. [Receipt Service](#receipt-service)
8. **Swagger**
    - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

### Dictionary Service
Сервис для работы со странами и участниками, которые принимали участие в фильме (актёры и режиссёры). Порт данного 
сервиса 8031

#### Краткое описание
1. **Страны**:
   - **GET /api/v1/dictionary/countries** - Получение всех записей о странах (Доступно для любого авторизованного 
   клиента)
   - **GET /api/v1/dictionary/countries/search?code={code}** - Поиск записи о стране по коду (Доступно для любого 
   авторизованного клиента)
   - **GET /api/v1/dictionary/countries/search/codes?values=[value1,value2,valueN]** - Получение записей стран по 
   переданным кодам (Доступно для любого авторизованного клиента)
   - **GET /api/v1/dictionary/countries/search/not-exists/codes?values=[value1,value2,valueN]** - Получение списка 
   кодов стран, которые не принадлежат не одной существующей записи страны (Доступно для любого авторизованного клиента)
2. **Участники фильмов**
   - **GET /api/v1/dictionary/participants** - Получение всех записей об участниках фильмов (Доступно для любого 
   авторизованного клиента)
   - **GET /api/v1/dictionary/participants/{id}** - Поиск записи об участнике фильма по идентификатору (Доступно для 
   любого авторизованного клиента)
   - **GET /api/v1/dictionary/participants/search/ids?values=[value1,value2,valueN]** - Получение записей участников 
   фильмов по переданным идентификаторам (Доступно для любого авторизованного клиента)
   - **GET /api/v1/dictionary/participants/search/not-exists/ids?values=[value1,value2,valueN]** - Получение списка 
   идентификаторов участников фильма, которые не принадлежат не одной существующей записи участников фильмов (Доступно 
   для любого авторизованного клиента)
3. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Страны**
   - **GET /api/v1/dictionary/countries**
      - Приходит запрос 
      - В БД выполняется поиск всех доступных записей о странах
      - В ответе возвращается список объектов типа **CountryResponse** с кодом 200
   - **GET /api/v1/dictionary/countries/search?code={code}**
      - Приходит запрос с кодом страны в переменной **code**
      - В БД выполняется поиск записи по переданному коду из переменной **code** 
        - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Иначе в ответе возвращается объект типа **CountryResponse** с кодом 200
   - **GET /api/v1/dictionary/countries/search/search/codes?values=[value1,value2,valueN]**
      - Приходит запрос со списком кодов стран в переменной **values**
      - В БД выполняется поиск записей по переданному списку кодов стран из переменной **values**
      - В ответе возвращается список объектов типа **CountryResponse** с кодом 200
   - **GET /api/v1/dictionary/countries/search/not-exists/codes?values=[value1,value2,valueN]**
      - Приходит запрос со списком кодов стран в переменной **values**
      - В БД выполняется фильтрация кодов из переданного списка кодов стран из переменной **values**, записи с кодами 
      которых не существуют в БД
      - В ответе возвращается список кодов стран типа **String** с кодом 200
2. **Участники фильмов**
   - **GET /api/v1/dictionary/participants**
      - Приходит запрос
      - В БД выполняется поиск всех доступных записей об участниках фильмов
      - В ответе возвращается список объектов типа **ParticipantResponse** с кодом 200
   - **GET /api/v1/dictionary/participants/{id}**
      - Приходит запрос с идентификатором участника фильма в переменной **id**
      - В БД выполняется поиск записи по переданному идентификатору из переменной **id**
         - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
         - Иначе в ответе возвращается объект типа **ParticipantResponse** с кодом 200
   - **GET /api/v1/dictionary/participants/search/search/ids?values=[value1,value2,valueN]**
      - Приходит запрос со списком идентификаторов участников фильмов в переменной **values**
      - В БД выполняется поиск записей по переданному списку идентификаторов участников фильмов из переменной **values**
      - В ответе возвращается список объектов типа **ParticipantResponse** с кодом 200
   - **GET /api/v1/dictionary/participants/search/not-exists/ids?values=[value1,value2,valueN]**
      - Приходит запрос со списком идентификаторов участников фильмов в переменной **values**
      - В БД выполняется фильтрация идентификаторов из переданного списка идентификаторов участников фильмов из переменной 
      **values**, записи с идентификаторами которых не существуют в БД
      - В ответе возвращается список идентификаторов участников фильма типа **Long** с кодом 200


### File Service
Сервис для работы с изображениями для фильмов. Порт данного сервиса 8032

#### Краткое описание
1. **Файлы**
   - **GET /api/v1/file/images** - Получение записей всех изображений (Доступно для пользователей с ролью admin 
   и manager)
   - **GET /api/v1/file/images/movie/{movie-id}** - Получение записей всех изображений по идентификатору фильму 
   (Доступно для любого авторизованного клиента)
   - **GET /api/v1/file/images/resource/{movie-id}/{number}** - Получение объекта изображения по идентификатору фильма 
   и порядковому номеру изображения (Доступно для всех)
   - **POST /api/v1/file/images/movie/{movie-id}/image** - Создание нового изображения для определенного фильма 
   (Доступно для пользователей с ролью admin и manager)
   - **PUT /api/v1/file/images/numbers** - Изменение порядкового номера в записях об изображениях (Доступно для 
   пользователей с ролью admin и manager)
   ```
    Пример тела запроса:
     [  
        {
            "id": "6907d9c5-e669-4aec-926b-2a617f509b20",
            "movieId": 1,
            "fileName": "test-one.jpg",
            "number": 1
        },
        {
            "id": "867f6754-188f-4fa5-8984-4f170fb0a50a",
            "movieId": 1,
            "fileName": "test-two.jpeg",
            "number": 2
        }
     ]    
   ```
   - **DELETE /api/v1/file/images/{id}** - Удаление записи по идентификатору (Доступно для пользователей с 
   ролью admin и manager)
2. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Файлы**
    - **GET /api/v1/file/images**
        - Приходит запрос
        - В БД выполняется поиск всех доступных записей об изображениях
        - В ответе возвращается список объектов типа **ImageResponse** с кодом 200
   - **GET /api/v1/file/images/movie/{movie-id}**
       - Приходит запрос с идентификатором фильма в переменной **movie-id**
       - В БД выполняется поиск всех доступных записей об изображениях по переданному идентификатору фильма из переменной 
       **movie-id**
       - В ответе возвращается список объектов типа **ImageResponse** с кодом 200
   - **GET /api/v1/file/images/resource/{movie-id}/{number}**
       - Приходит запрос с идентификатором фильма в переменной **movie-id** и порядковым номером в переменной 
        **number**
       - В БД выполняется поиск записи об изображении по переданным идентификатору фильма из переменной **movie-id** и 
       порядковому номеру изображения из переменной **number**
            - Если запись не найдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 404
            - Иначе выполняется поиск файла изображения в директории с изображениями и в ответе возвращается файл 
            изображения с кодом 200
   - **POST /api/v1/file/images/movie/{movie-id}/image**
       - Приходит запрос с идентификатором фильма в переменной **movie-id** и файлом изображения в переменной **image**
       - Выполняется проверка расширения файла
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
       - В БД выполняется проверка на существование записи с наименованием файла из переменной **image**
            - Если запись о файле с таки наименованием файла уже существует, то в ответе возвращается объект типа 
            **ApiErrorResponse** с кодом 409
       - Выполняется сохранение переданного файла из переменной **image**
            - Если файл в директории с таким же наименованием уже существует, то в ответе возвращается объект типа
              **ApiErrorResponse** с кодом 409
       - В БД выполняется поиск количества записей об изображениях с идентификатором фильма из переменной **movie-id**
       - В БД выполняется сохранение новой записи об изображении
       - В ответе возвращается код 201
   - **PUT /api/v1/file/images/numbers**
       - Приходит запрос с JSON в переменной **requests**, где содержатся объекты типа **ImageRequest**
       - Объекты типа **ImageRequest** из переменной **requests** проходят валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 400
       - Выполняется проверка на то, что у объектов из переменной **requests** одинаковые значения в поле **movieId**
            - Если проверка не пройдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 400
       - Выполняется проверка на то, что порядковых номер изображения столько же, сколько и переданных объектов в 
       переменной **requests**
            - Если проверка не пройдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 400
       - Выполняется проверка на то, что номера в поле **number** у объектов из переменной **requests** расположены по 
       порядку
            - Если проверка не пройдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 400
       - В БД выполняется обновление номеров у каждой записи
       - В ответе возвращается код 200
   - **DELETE /api/v1/file/images/{id}**
        - Приходит запрос с идентификатором изображения в переменной **id**
        - Выполняется поиск записи об изображении по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется удаление файла по наименованию из директории на диске
        - В БД выполняется удаление записи по идентификатору изображения из переменной **id**
        - В ответе возвращается код 204

### Movie Service
Сервис для работы с фильмами и жанрами к фильмам. Порт данного сервиса 8033

#### Краткое описание
1. **Жанры**
   - **GET /api/v1/genres** - Получение всех записей о жанрах (Доступно для пользователей с ролью admin и manager)
2. **Фильмы**
   - **GET /api/v1/movies** - Получение всех записей о фильмах (Доступно для всех)
   ```
   Пример запросов:
   /api/v1/movies
   /api/v1/movies?name=Тест
   /api/v1/movies?name=Тест&year=1994
   /api/v1/movies?name=Тест&year=1994&rental=true
   ```
   - **GET /api/v1/movies/{id}** - Получение записи о фильме по идентификатору (Доступно для всех)
   - **GET /api/v1/movies/{id}/duration** - Получение продолжительности фильма по идентификатору (Доступно для любого 
   авторизованного клиента)
   - **GET /api/v1/movies/exists/{id}** - Проверка на существование записи о фильме по идентификатору (Доступно для 
   любого авторизованного клиента)
   - **POST /api/v1/movies** - Создание новой записи о фильме (Доступно для пользователей с ролью admin и manager)
    ```
     Пример тела запроса:
     {
		     "name": "Тест",
		     "description": "Тест",
		     "duration": 66,
		     "year": 2020,
		     "ageRating": "SIX",
		     "rental": false,
		     "genreIds": [4],
		     "countryCodes": ["056"],
		     "directorIds": [9],
		     "actorIds": [10]
     }
    ```
   - **PUT /api/v1/movies/{id}** - Обновление существующей записи о фильме (Доступно для пользователей с ролью admin 
   и manager)
    ```
     Пример тела запроса:
     {
		     "name": "Тест1234",
		     "description": "Тест 1234",
		     "duration": 77,
		     "year": 2016,
		     "ageRating": "EIGHTEEN",
		     "rental": true,
		     "genreIds": [1,2],
		     "countryCodes": ["152","250"],
		     "directorIds": [1,2],
		     "actorIds": [11,12]
     }
    ```
   - **DELETE /api/v1/movies/{id}** - Удаление записи о фильме по идентификатору (Доступно для пользователей с ролью 
   admin)
3. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Жанры**
    - **GET /api/v1/genres**
        - Приходит запрос
        - В БД выполняется поиск всех доступных записей о жанрах к фильмам
        - В ответе возвращается список объектов типа **GenreResponse** с кодом 200
2. **Фильмы**
    - **GET /api/v1/movies**
        - Приходит запрос с переменной **searchRequest** объекта типа **MovieSearchRequest**
            ```
            Пример запросов:
            /api/v1/movies
            /api/v1/movies?name=Тест
            /api/v1/movies?name=Тест&year=1994
            /api/v1/movies?name=Тест&year=1994&rental=true
            ```
        - В БД выполняется поиск всех доступных записей о фильмах без параметров или с параметрами из переменной 
        **searchRequest** объекта типа **MovieSearchRequest**
        - Выполняется построение полных объектов типа **MovieResponse**, где для получения объектов типа 
        **CountryResponse** и **ParticipantResponse** необходимо обратиться к сервису **Dictionary Service**
        - В ответе возвращается список объектов типа **MovieResponse** с кодом 200
    - **GET /api/v1/movies/{id}**
        - Приходит запрос с идентификатором фильма в переменной **id**
        - В БД выполняется поиск записи по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется построение полного объекта типа **MovieResponse**, где для получения объектов типа 
        **CountryResponse** и **ParticipantResponse** необходимо обратиться к сервису **Dictionary Service**
        - В ответе возвращается объект типа **MovieResponse** с кодом 200
    - **GET /api/v1/movies/{id}/duration**
        - Приходит запрос с идентификатором фильма в переменной **id**
        - В БД выполняется поиск продолжительности фильма по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В ответе возвращается тип **Integer** с кодом 200
    - **GET /api/v1/movies/exists/{id}**
        - Приходит запрос с идентификатором фильма в переменной **id**
        - В БД выполняется поиск на существование записи о фильме по переданному идентификатору из переменной **id**
        - В ответе возвращается тип **Boolean** с кодом 200
    - **POST /api/v1/movies**
        - Приходит запрос с JSON в переменной **request**, где содержится объекты типа **MovieRequest**
        - Объект типа **MovieRequest** из переменной **request** проходит валидацию полей
           - Если проверка не пройдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 400
        - В БД выполняется сохранение новой записи о фильме с основными данными
        - Выполняется сохранение жанров для фильма в БД
            - Если некоторых жанров из переданного списка идентификаторов жанров в поле **genreIds** объекта типа 
            **MovieRequest** переменной **request** не существует, то в ответе возвращается объект типа 
            **ApiErrorResponse** с кодом 400
        - Выполняется сохранение стран для фильма в БД
            - Выполняется проверка на существование из переданного списка кодов стран в поле **countryCodes** объекта 
            типа **MovieRequest** переменной **request** через запрос к сервису **Dictionary Service** 
                - Если некоторых кодов стран не существует, то в ответе возвращается объект типа **ApiErrorResponse** с 
                кодом 400
        - Выполняется сохранение участников фильмов для фильма в БД
            - Выполняется проверка на существование из переданного списка идентификаторов участников фильмов в поле 
            **directorIds** объекта типа **MovieRequest** переменной **request** через запрос к сервису 
            **Dictionary Service** 
                - Если некоторых участников фильмов не существует, то в ответе возвращается объект типа 
                **ApiErrorResponse** с кодом 400
        - Выполняется построение полного объекта типа **MovieResponse**, где для получения объектов типа 
        **CountryResponse** и **ParticipantResponse** необходимо обратиться к сервису **Dictionary Service**
        - В ответе возвращается объект типа **MovieResponse** с кодом 201
    - **PUT /api/v1/movies/{id}**
        - Приходит запрос с идентификатором фильма в переменной **id** и с JSON в переменной **request**, где содержится 
        объект типа **MovieRequest**
        - Объект типа **MovieRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа ApiErrorResponse с кодом 400
        - В БД выполняется поиск записи по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется обновление основных данных о фильме
        - Выполняется обновление жанров для фильма в БД
            - Если некоторых жанров из переданного списка идентификаторов жанров в поле **genreIds** объекта типа
              **MovieRequest** переменной **request** не существует, то в ответе возвращается объект типа
              **ApiErrorResponse** с кодом 400
        - Выполняется обновление стран для фильма в БД
            - Выполняется проверка на существование из переданного списка кодов стран в поле **countryCodes** объекта 
            типа **MovieRequest** переменной **request** через запрос к сервису **Dictionary Service** 
                - Если некоторых кодов стран не существует, то в ответе возвращается объект типа **ApiErrorResponse** с 
                кодом 400
        - Выполняется обновление участников фильмов для фильма в БД
            - Выполняется проверка на существование из переданного списка идентификаторов участников фильмов в поле
            **directorIds** объекта типа **MovieRequest** переменной **request** через запрос к сервису 
            **Dictionary Service** 
                - Если некоторых участников фильмов не существует, то в ответе возвращается объект типа 
                **ApiErrorResponse** с кодом 400
        - В БД выполняется обновление существующей записи о фильме с основной информацией
        - Выполняется построение полного объекта типа **MovieResponse** из объекта типа **Movie**, где для получения
          объектов типа **CountryResponse** и **ParticipantResponse** необходимо обратиться к сервису **Dictionary Service**
        - В ответе возвращается объект типа **MovieResponse** с кодом 200
    - **DELETE /api/v1/movies/{id}**
        - Приходит запрос с переданным идентификатором фильма в переменной **id**
        - Выполняется проверка на существование записи с переданным идентификатором фильма из переменной **id**
            - Если запись не существует, то в ответ возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется удаление записи по переданному идентификатору фильма из переменной **id**
        - В ответе возвращается код 204

### Session Service
Сервис для работы с сеансами к фильмам и местами к сеансам. Порт данного сервиса 8034

#### Краткое описание
1. **Сеансы**
   - **GET /api/v1/sessions** - Получение всех записей о сеансах (Доступно для всех)
   ```
   Пример запросов:
   /api/v1/sessions
   /api/v1/sessions?movieId=1
   /api/v1/sessions?movieId=1&date=2014-01-01
   ```
   - **GET /api/v1/sessions/{id}** - Получение записи о сеансе по идентификатору (Доступно для всех)
   - **POST /api/v1/sessions** - Создание новой записи о сеансе (Доступно для пользователей с ролью admin и manager)
   ```
   Пример тела запроса:
    {
	     "movieId": 1,
	     "movieFormat": "THREE_D",
	     "hall": 2,
	     "dateTime": "2025-11-28T14:00:00.00Z",
	     "available": true
    }
   ```
   - **PUT /api/v1/sessions/{id}** - Обновление существующей записи о сеансе (Доступно для пользователей с ролью admin 
   и manager)
   ```
   Пример тела запроса:
    {
	     "movieId": 2,
	     "movieFormat": "TWO_D",
	     "hall": 4,
	     "dateTime": "2026-12-29T10:00:00.00Z",
	     "available": false
    }
   ```
   - **DELETE /api/v1/sessions/{id}** - Удаление записи о сеансе по идентификатору (Доступно для пользователей с ролью 
   admin)
2. **Места**
   - **GET /api/v1/places** - Получение всех записей о местах сеансов (Доступно для пользователей с ролью admin и manager)
   - **GET /api/v1/places/session/{session-id}** - Получение записей мест сеанса по идентификатору сеанса (Доступно 
   для всех)
   - **GET /api/v1/places/search/ids?values=[value1,value2,valueN]** - Получение записей мест по переданному списку 
   идентификаторов (Доступно для любого авторизованного клиента)
   - **GET /api/v1/places/{id}** - Получение записи о месте сеанса по идентификатору (Доступно для всех)
   - **GET /api/v1/places/search/session/{session-id}/ids?values=[value1,value2,valueN]&available={available}** - 
   Получение первого идентификатора места сеанса, который равен переданному идентификатору сеанса и доступности из 
   списка идентификаторов мест (Доступно для любого авторизованного клиента)
   - **GET /api/v1/places/search/session-not-equals/{session-id}/ids?values=[value1,value2,valueN]** - Получение первого 
   идентификатора места сеанса, который не равен переданному идентификатору сеанса из списка идентификаторов мест 
   (Доступно для любого авторизованного клиента)
   - **POST /api/v1/places** - Создание новой записи о месте сеанса (Доступно для пользователей с ролью admin и manager)
   ```
   Пример тела запроса:
    {
	     "sessionId": 10,
	     "row": 2,
	     "number": 8,
	     "price": "300.00",
	     "available": true
    }
   ```
   - **PUT /api/v1/places/{id}** - Обновление существующей записи о месте сеанса  (Доступно для пользователей с ролью 
   admin и manager)
   ```
   Пример тела запроса:
    {
	     "sessionId": 10,
	     "row": 1,
	     "number": 4,
	     "price": "200.00",
	     "available": true
    }
   ```
   - **PATCH /api/v1/places/ids/update/available-places?sessionId={sessionId}&ids=[value1,value2,valueN]&available={available}** - 
   Обновление доступности мест сеанса (Доступно для пользователей с ролью admin, manager и client)
   - **DELETE /api/v1/places/{id}** - Удаление записи о месте сеанса по идентификатору (Доступно для пользователей 
   с ролью admin)
3. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Сеансы**
    - **GET /api/v1/sessions**
        - Приходит запрос с переменной **searchRequest** объекта типа **SessionSearchRequest**
            ```
            Пример запросов:
            /api/v1/sessions
            /api/v1/sessions?movieId=1
            /api/v1/sessions?movieId=1&date=2014-01-01
            ```
        - В БД выполняется поиск всех доступных записей о сеансах без параметров или с параметрами из переменной 
        **searchRequest** объекта типа **SessionSearchRequest**
        - В ответе возвращается список объектов типа **SessionResponse** с кодом 200
    - **GET /api/v1/sessions/{id}**
        - Приходит запрос с идентификатором сеанса в переменной **id**
        - В БД выполняется поиск записи по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В ответе возвращается объект типа **SessionResponse** с кодом 200
    - **POST /api/v1/sessions**
        - Приходит запрос с JSON в переменной **request**, где содержится объект типа **SessionRequest**
        - Объект типа **SessionRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - Выполняется проверка на существование фильма с переданным идентификатором в поле **movieId** объекта типа 
        **SessionRequest** из переменной **request** через запрос к сервису **Movie Service**
            - Если фильм не найден, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется проверка на существование сеанса по номеру зала из поля **number** и дате с временем из поля 
        **dateTime** объекта типа **SessionRequest** переменной **request**
            - Если сеанс существует с таким номером зала и датой с временем, то в ответе возвращается объект типа 
            **ApiErrorResponse** с кодом 409
        - В БД выполняется сохранение новой записи о сеансе
        - Выполняется проверка на значение **available**
          - Если значение **available** равно **true**
            - В очередь сообщений отправляется сообщение о создании задачи по проверке бронирований по идентификатору сеанса
            - В очередь сообщений отправляется сообщение о создании задачи по завершении доступности сеанса
        - В ответе возвращается объект типа **SessionResponse** с кодом 201
    - **PUT /api/v1/sessions/{id}**
        - Приходит запрос с идентификатором сеанса в переменной **id** и с JSON в переменной **request**, где 
        содержится объекты типа **SessionRequest**
        - Объект типа **SessionRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется поиск записи по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется замена данных о сеансе
            - Если фильм не найден по полю **movieId** объекта **SessionRequest** из переменной **request**, то в ответе 
            возвращается объект типа **ApiErrorResponse** с кодом 404
            - Если сеанс существует с таким номером зала из поля **number** и датой с временем из поля **dateTime** 
            объекта **SessionRequest** переменной **request**, то в ответе возвращается объект типа **ApiErrorResponse** 
            с кодом 409
        - В БД выполняется обновление существующей записи о сеансе
        - Происходит проверка на старое значение **available** было равно значению **true**
          - Если оно равно **true**, то происходит следующая проверка 
            - Если **available** не равен значению **available** из объекта **request** типа **SessionRequest** и 
            значение из объекта **request** типа **SessionRequest** равно **false**
              - В очередь сообщений отправляется сообщение об удалении задачи о проверке бронирований по идентификатору 
              сеанса и о завершении доступности сеанса
            - Иначе
              - Если значение **dateTime** из объекта **request** типа **SessionRequest** не равно **null*
                - Если старое значение **dateTime** не равно значению **dateTime** из объекта **request** типа 
                **SessionRequest**
                  - В очередь сообщений отправляется сообщение об обновлении задачи по проверке бронирований по 
                  идентификатору сеанса
                  - В очередь сообщений отправляется сообщение об обновлении задачи по завершении доступности сеанса
          - Иначе
            - Выполняется проверка на значение **available** из объекта **request** типа **SessionRequest**
                - Если значение **available** равно **true**
                  - В очередь сообщений отправляется сообщение о создании задачи по проверке бронирований по 
                  идентификатору сеанса
                  - В очередь сообщений отправляется сообщение о создании задачи по завершении доступности сеанса
        - В ответе возвращается объект типа **SessionResponse** с кодом 200
    - **DELETE /api/v1/sessions/{id}**
        - Приходит запрос с идентификатором сеанса в переменной **id**
        - В БД выполняется проверка записи на существование по переданному идентификатору из переменной **id**
            - Если запись не существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется удаление существующей записи по идентификатору сеанса из переменной **id**
        - В очередь сообщений отправляется сообщение об удалении задачи о проверке бронирований по идентификатору
          сеанса и о завершении доступности сеанса 
        - В ответе возвращается код 204
2. **Места**
    - **GET /api/v1/places**
        - Приходит запрос
        - В БД выполняется поиск всех доступных мест сеансов
        - В ответе возвращается список объектов типа **PlaceResponse** с кодом 200
    - **GET /api/v1/places/session/{session-id}**
        - Приходит запрос с идентификатором сеанса в переменной **session-id**
        - В БД выполняется поиск записей о местах по идентификатору сеанса из переменной **session-id**
        - В ответе возвращается список объектов типа **PlaceResponse** с кодом 200
    - **GET /api/v1/places/search/ids?values=[value1,value2,valueN]**
        - Приходит запрос со списком идентификаторов мест в переменной **values**
        - В БД выполняется поиск записей по переданному списку идентификаторов мест из переменной **values**
        - В ответе возвращается список объектов типа **PlaceResponse** с кодом 200
    - **GET /api/v1/places/{id}**
        - Приходит запрос с идентификатором места в переменной **id**
        - В БД выполняется поиск записи по переданному идентификатору из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В ответе возвращается объект типа **PlaceResponse** с кодом 200
    - **GET /api/v1/places/search/session/{session-id}/ids?values=[value1,value2,valueN]&available={available}**
        - Приходит запрос с идентификатором сеанса в переменной **session-id**, списком идентификаторов мест в 
        переменной **values** и доступностью в переменной **available**
        - В БД выполняется поиск идентификаторов мест из переменной **values**, которые равны переданной 
        доступности из переменной **available** м идентификатору сеанса из переменной **session-id**. 
        После получения этих идентификаторов, берется первый идентификатор места
            - Если идентификатор места пустой, то в ответе возвращается число 0 типа **Long** с кодом 200
            - Иначе в ответе возвращается идентификатор места типа **Long** с кодом 200
    - **GET /api/v1/places/search/session-not-equals/{session-id}/ids?values=[value1,value2,valueN]**
        - Приходит запрос с идентификатором сеанса в переменной **session-id**, списком идентификаторов мест в
          переменной **values**
        - В БД выполняется поиск идентификаторов мест из переменной **values**, которые не принадлежат ни одной записи 
        с переданным идентификатором сеанса в переменной **session-id**. После получения этих идентификаторов, берется 
        первый идентификатор места
            - Если идентификатор места пустой, то в ответе возвращается число 0 типа **Long** с кодом 200
            - Иначе в ответе возвращается идентификатор места типа **Long** с кодом 200
    - **POST /api/v1/places**
        - Приходит запрос с JSON в переменной **request**, где содержится объект типа **PlaceRequest**
        - Объект типа **PlaceRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется проверка на существование места с таким же идентификатором сеанса, номером ряда и номера места
            - Если запись с такими параметрами уже существует, то в ответе возвращается объект типа **ApiErrorResponse** 
            с кодом 409
        - В БД происходит поиск сеанса по полю **id** объекта типа **PlaceRequest** переменной **request**
            - Если запись не найдена, то в ответ возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется сохранение новой записи о месте сеанса
        - В ответе возвращается объект типа **PlaceResponse** с кодом 201
    - **PUT /api/v1/place/{id}**
        - Приходит запрос с идентификатором места сеанса и JSON в переменной **request**, где содержится объект типа 
        **PlaceRequest**
        - Объект типа **PlaceRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется поиск места сеанса по идентификатору места сеанса из переменной **id**
            - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется обновление данных
            - Если обновляется идентификатор сеанса, то в БД выполняется поиск записи сеанса с другим идентификатором
                - Если запись не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
            - Если обновляется номер ряда или номер места, то в БД происходит проверка на то, существует ли уже запись 
            о сеансе с такими данными
                - Если место сеанса существует с таким номером ряда из поля **row** и номером места из поля **number**
                объекта **PlaceRequest** переменной **request**, то в ответе возвращается объект типа **ApiErrorResponse**
                с кодом 409
        - В БД выполняется обновление существующей записи о месте сеанса
        - В ответ возвращается объект типа **PlaceResponse** с кодом 200
    - **PATCH /api/v1/places/ids/update/available-places?sessionId={sessionId}&ids=[value1,value2,valueN]&available={available}**
        - Приходит запрос с идентификатором сеанса в переменной **sessionId**, списком идентификаторов мест сеансов в 
        переменной **ids** и доступностью места в переменной **available**
        - В БД выполняется поиск мест по указанным идентификаторам мест с необходимым идентификатором сеанса и 
        затем выполняется обновление доступности мест у найденных записей мест сеансов
        - В ответе возвращается код 200
    - **DELETE /api/v1/places/{id}**
        - Приходит запрос с идентификатором места сеанса
        - В БД выполняется проверка на существование места сеанса по идентификатору места сеанса из переменной **id**
            - Если запись не найдена, то в ответ возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется удаление записи места сеанса по идентификатору места сеанса из переменной **id**
        - В ответе возвращается код 204

#### Фоновые задачи
##### Отключение доступности сеанса
- Из очереди приходит идентификатор сеанса **sessionId** типа **String**
- По этому идентификатору происходит обновление доступности сеанса

##### Обновление доступности мест после проверки бронирований
- Из очереди приходит объект **request** типа **TaskResponse**
- Из **additionalProperties** типа **Map<String, Object>** в **request** берется значение с ключом **sessionId**
- Из **data** типа **Map<String, Object>** в **request** берутся ключи и приводятся к типу **Long**
- Из **additionalProperties** типа **Map<String, Object>** в **request** берется значение с ключом **available**
- Происходит обновление доступности мест по идентификатору сеансов, списку идентификаторов мест и доступности

### User Service
Сервис для работы с пользователями системы и с ролями пользователей. Порт данного сервиса 8035

#### Краткое описание
1. **Роли**
   - **GET /api/v1/roles** - Получение всех записей о ролях пользователей (Доступно для пользователей с ролью admin)
   - **PUT /api/v1/roles/user/{id}?currentRole={currentRole}&newRole={newRole}** - Обновление роли пользователю 
   (Доступно для пользователей с ролью admin)
2. **Пользователи**
   - **GET /api/v1/users** - Получение всех записей о пользователях (Доступно для пользователей с ролью admin и manager)
   - **GET /api/v1/users/{id}** - Получение записи о пользователе по идентификатору (Доступно для пользователей с 
   ролью admin, manager и client)
   - **POST /api/v1/users** - Создание новой записи о пользователе (Доступно для всех)
   - **PUT /api/v1/users/{id}** - Обновление существующей записи о пользователе (Доступно для пользователей с ролью 
   admin, manager и client)
   - **DELETE /api/v1/users/{id}** - Удаление записи о фильме по идентификатору (Доступно для пользователей с ролью admin)
   - **PATCH /api/v1/users/{id}/send-verify-email** - Отправка письма по электронной почте для подтверждения 
   электронной почты (Доступно для пользователей с ролью admin, manager и client)
   - **PUT /api/v1/users/reset-password?username={username}** - Сброс пароля и отправка письма на электронную почту (Доступно для всех)
   - **PATCH /api/v1/users/{id}/activity** - Обновление активности аккаунта (Доступно для пользователей с ролью admin)
   - **PUT /api/v1/users/{id}/update-password** - Обновление пароля пользователю (Доступно для пользователей с ролью 
   admin, manager и client)
3. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Роли**
    - **GET /api/v1/roles**
        - Приходит запрос
        - Из Keycloak запрашиваются все доступные роли пользователей
        - В ответе возвращается список объектов типа **RoleResponse** с кодом 200
    - **PUT /api/v1/roles/user/{id}?currentRole={currentRole}&newRole={newRole}**
        - Приходит запрос с идентификатором пользователя в переменной **id**, текущей ролью пользователя в переменной 
        **currentRole** и новой ролью пользователя в переменной **newRole**
        - Выполняется обновление роли пользователя в Keycloak
        - В ответе возвращается код 200
2. **Пользователи**
    - **GET /api/v1/users**
        - Приходит запрос
        - Из Keycloak запрашиваются все доступные пользователей
        - В ответе возвращается список объектов типа **UserResponse** с кодом 200
    - **GET /api/v1/users/{id}**
        - Приходит запрос с идентификатором пользователя
        - Идёт проверка пользователя
            - Если пользователь, отправивший запрос, имеет роль **client** и его идентификатор пользователя не равен 
            идентификатору пользователя, который он передал в переменной **id**, то в ответе возвращается объект 
            типа **ApiErrorResponse** с кодом 403
        - Из Keycloak запрашивается пользователь по идентификатору пользователя из переменной **id**
        - В ответе возвращается объект типа **UserResponse** с кодом 200
    - **POST /api/v1/users**
        - Приходит запрос с JSON в переменной **request**, где содержится объект типа **UserRegistrationRequest**
        - Объект типа **UserRegistrationRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - Выполняется проверка на существование пользователя в Keycloak с именем пользователя из поля **username** 
        объекта типа **UserRegistrationRequest** переменной **request**
            - Если пользователь с таким именем пользователя найден, то в ответе возвращается объект типа 
            **ApiErrorResponse** с кодом 409
        - Выполняется проверка на существование пользователя в Keycloak c электронной почтой из поля **email** 
        объекта типа **UserRegistrationRequest** из переменной **request**
            - Если пользователь с таким именем пользователя найден в Keycloak, то в ответе возвращается объект типа
              **ApiErrorResponse** с кодом 409
        - Создаётся пользователь в Keycloak и ему присваивается роль **client**
        - Отправляется письмо на электронную почту для подтверждения электронной почты
        - В очередь сообщений отправляется сообщение о создании задачи по деактивации пользователя, если он не 
        подтвердил электронную почту
        - В ответе возвращается код 201
    - **PUT /api/v1/users/{id}**
        - Приходит запрос с идентификатором пользователя в переменной **id** и JSON в переменной **request**, где 
        содержится объект типа **UserRequest**
        - Идёт проверка пользователя
            - Если пользователь, отправивший запрос, имеет роль **client и его идентификатор пользователя не равен
              идентификатору пользователя, который он передал в переменной **id**, то в ответе возвращается объект
              типа **ApiErrorResponse** с кодом 403
        - Объект типа **UserRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - Из Keycloak запрашивается пользователь по идентификатору пользователя из переменной **id**
        - Выполняется обновление данных
            - Если при обновлении данных поменялась электронная почта, то отправляется письмо на электронную почту для 
            подтверждения новой электронной почты
        - Обновляется пользователь в Keycloak
        - В ответе возвращается объект типа **UserResponse** с кодом 200
    - **DELETE /api/v1/users/{id}**
        - Приходит запрос с идентификатором пользователя в переменной **id**
        - Отправляется запрос в Keycloak на удаление пользователя по идентификатору пользователя из переменной **id**
            - Если пользователь не найден, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В ответе возвращается код 204
    - **PATCH /api/v1/users/{id}/send-verify-email**
        - Приходит запрос с идентификатором пользователя в переменной **id**
        - Идёт проверка пользователя
            - Если пользователь, отправивший запрос, имеет ролью **client** и его идентификатор пользователя не равен
              идентификатору пользователя, который он передал в переменной **id**, то в ответе возвращается объект
              типа **ApiErrorResponse** с кодом 403
        - Из Keycloak запрашивается пользователь по идентификатору пользователя из переменной **id**
            - Если у пользователя уже подтверждена электронная почта, то в ответе возвращается объект типа 
            **ApiErrorResponse** с кодом 409
        - Отправляется письмо на электронную почту для подтверждения электронной почты
        - В ответе возвращается код 200
    - **PUT /api/v1/users/reset-password?username={username}**
        - Приходит запрос с именем пользователя в переменной **username**
        - Из Keycloak запрашивается пользователь по имени пользователя из переменной **username**
        - Отправляется запрос в Keycloak на определенного пользователя для обновления пароля и затем на электронную 
        почту полученного пользователя отправляется ссылка для смены пароля
        - В ответе возвращается код 200
    - **PATCH /api/v1/users/{id}/activity**
        - Приходит запрос с идентификатором пользователя в переменной **id**
        - Из Keycloak запрашивается пользователь по идентификатору пользователя из переменной **id**
        - Меняется значение активности у пользователя в Keycloak
        - В ответе возвращается код 200
    - **PUT /api/v1/users/{id}/update-password**
        - Приходит запрос с идентификатором пользователя в переменной **id**
        - Идёт проверка пользователя
            - Если у пользователя, отправившего запрос идентификатор пользователя не равен идентификатору пользователя, 
            который он передал в переменной **id**, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 403
        - Из Keycloak запрашивается пользователь по идентификатору пользователя из переменной **id**
        - Отправляется запрос в Keycloak на определенного пользователя для обновления пароля и затем на электронную
          почту полученного пользователя отправляется ссылка для смены пароля
        - В ответе возвращается код 200

#### Фоновые задачи
##### Деактивация клиента
- Из очереди приходит идентификатор клиента
- По этому идентификатору происходит поиск клиента
- Идёт проверка на неподтвержденную электронную почту 
  - Если у клиента неподтвержденная электронная почта, то происходит деактивация аккаунта

##### Удаление клиентов
- Из очереди приходит объект типа **TaskResponse**
- Происходит проверка на то, что в мапе из поля **data** присутствует пара ключ-значение с ключом **userState**
    - Если не существует такой пары, то происходит исключение
- Происходит проверка на то, что значение из **userState** равно **DELETE_INACTIVE** из перечисления **UserState**
    - Если равно, то 
      - Происходит получение всех пользователей и фильтрация на тех, у кого деактивированный аккаунт 
      - Выполняется удаление деактивированных клиентов


### Booking Service
Сервис для работы с бронированием сеансов на просмотр фильмов в кинотеатре. Порт данного сервиса 8036

#### Краткое описание
1. **Бронирование**
   - **GET /api/v1/bookings** - Получение всех записей о бронированиях (Доступно для пользователей с ролью admin, 
   manager и client)
       ```
       Пример запросов:
       /api/v1/bookings
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1&bookingStatus=PAID
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1&bookingStatus=PAID&from=2014-01-01
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1&bookingStatus=PAID&from=2014-01-01&to=2020-05-05
       ```
   - **GET /api/v1/bookings/{id}** - Получение записи о бронировании по идентификатору (Доступно для пользователей с 
   ролью admin, manager и client)
   - **POST /api/v1/bookings** - Создание новой записи о бронировании (Доступно для пользователей с ролью admin, 
   manager и client)
    ```
    Пример тела запроса:
    {
	     "sessionId": 10,
	     "placeIds": [127],
	     "bookingStatus": "PAID"
    }
    ```
   - **PUT /api/v1/bookings/{id}** - Обновление существующей записи о бронировании (Доступно для пользователей с ролью 
   admin, manager и client)
    ```
    Пример тела запроса:
    {
	     "userId": "3c59a7b2-4cff-49b6-a654-3145ecdab36b",
	     "sessionId": 10,
	     "placeIds": [127],
	     "bookingStatus": "CREATED"
    }
    ```
   - **PATCH /api/v1/bookings/{id}/status** - Обновление статуса у существующей записи о бронировании (Доступно для 
   пользователей с ролью admin, manager и client)
    ```
    Пример тела запроса:
    {
	     "userId": "7116aae4-debe-473a-b492-4caee974dddd",
	     "bookingStatus": "PAID"
    }
    ```
   - **DELETE /api/v1/bookings/{id}** - Удаление записи о бронировании по идентификатору (Доступно для пользователей 
   с ролью admin)
   - **GET /api/v1/bookings/{id}/user?userId={userId}** - Проверка на существование бронирования по идентификатору и идентификатору 
   пользователя (Доступно для любого авторизованного клиента)
2. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Бронирование**
    - **GET /api/v1/bookings**
        - Приходит запрос с переменной **searchRequest** объекта типа **BookingSearchRequest**
        ```
       Пример запросов:
       /api/v1/bookings
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1&bookingStatus=PAID
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1&bookingStatus=PAID&from=2014-01-01
       /api/v1/bookings?userId=65f63102-d005-4a2f-970d-76efa2faac18&sessionId=1&bookingStatus=PAID&from=2014-01-01&to=2020-05-05
       ```
        - Выполняется проверка пользователя
            - Если пользователь, отправивший запрос, имеет роль **client**, то его идентификатор подставляется в 
            переменную **userId** объекта типа **BookingSearchRequest** переменной **request**
        - В БД выполняется поиск всех доступных записей о бронировании без параметров или с параметрами из 
        переменной **searchRequest** объекта типа **BookingSearchRequest**
        - Выполняется построение полных объектов типа **BookingResponse**, где для получения объектов типа 
        **SessionResponse** необходимо обратиться к сервису **Session Service**
        - В ответе возвращается список объектов типа **BookingResponse** с кодом 200
    - **GET /api/v1/bookings/{id}**
        - Приходит запрос с идентификатором бронирования в переменной **id**
        - Выполняется проверка пользователя
            - Если пользователь, отправивший запрос, имеет роль **client**, то в БД выполняется поиск по идентификатору 
            бронирования из переменной **id** и идентификатору пользователя из токена пользователя
                - Если запись о бронировании не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
            - Иначе в БД выполняется поиск только по идентификатору бронирования из переменной **id**
                - Если запись о бронировании не найдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется построение полных объектов типа **BookingResponse**, где для получения объектов типа 
        **SessionResponse** необходимо обратиться к сервису **Session Service**
        - В ответе возвращается объект типа **BookingResponse** с кодом 200
    - **POST /api/v1/bookings**
        - Приходит запрос с JSON в переменной **request**, где содержится объект типа **BookingRequest**
        - Выполняется проверка на идентификатор пользователя в поле **userId** объекта типа **BookingRequest** из
        переменной **request**
            - Если это поле равно null или у пользователя, отправившего запрос, роль **client**, то это поле заполняется 
            идентификатором пользователя из токена, который отправил запрос
        - Объект типа **BookingRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - Выполняется проверка на статус бронирования в поле **bookingStatus** объекта типа **BookingRequest** из
        переменной **request**
            - Если статус бронирования равен значению **CANCELED**, то в ответе возвращается объект типа 
            **ApiErrorResponse** с кодом 400
        - Выполняется проверка даты и времени начала сеанса фильма
            - Из сервиса **Session Service** по полю **sessionId** объект типа **BookingRequest** из переменной **request** 
            вызывается метод для получения объекта типа **SessionResponse**
                - Если поле **available** объекта типа **SessionResponse** содержит значение **false**, то в ответе 
                возвращается объект типа **ApiErrorResponse** с кодом 400
            - Из сервиса **Movie Service** по полю **movieId** объекта типа **SessionResponse** вызывается метод 
            для получения продолжительности фильма типа **Integer**
                - Если текущая дата и время + продолжительность фильма больше время начала сеанса, то в ответе
                возвращается объект типа **ApiErrorResponse** с кодом 400
        - Выполняется проверка доступности мест у сеанса для бронирования
            - Из сервиса **Session Service** по полю **sessionId** и **placeIds** объекта типа **BookingRequest** 
            из переменной **request** вызывается метод по получению места, который не принадлежит сеансу
                - Если вернулось не 0, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
            - Из сервиса **Session Service** по полю **sessionId** и **placeIds** объекта типа **BookingRequest**
              из переменной **request** вызывается метод по получению места, которое занято
                - Если вернулось не 0, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется создание новой записи о бронировании
        - Выполняется создание записей о местах для бронирования сеанса в таблицах данного сервиса и в сервисе 
        **Session Service** места по переданным идентификаторам в поле **placeIds** объекта типа **BookingRequest** 
        переменной **request** получают значение **false** в поле **available**
        - Выполняется построение полного объекта типа **BookingResponse**, где для получения объектов типа
          **SessionResponse** необходимо обратиться к сервису **Session Service**
        - Объект типа **BookingResponse** отправляется в очередь для создания квитанции о бронировании
        - В ответе возвращается объект типа **BookingResponse** с кодом 201
    - **PUT /api/v1/bookings/{id}**
        - Приходит запрос с идентификатором бронирования в переменной **id** JSON в переменной **request**, где 
        содержится объект типа **BookingRequest**
        - Выполняется проверка на идентификатор пользователя в поле **userId** объекта типа **BookingRequest**
          переменной **request**
            - Если это поле равно null, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - Объект типа **BookingRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется проверка на то, что у записи по переданному идентификатору не стоит статус **CANCELED**
            - Если возвращается результат **true**, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется поиск по идентификатору бронирования из переменной **id**
            - Если запись о бронировании не найдена, то в ответ возвращается объект типа ApiErrorResponse с кодом 404
        - Выполняется обновление данных о бронировании
            - Если идентификатор сеанса был изменен, то выполняется проверка даты и времени начала сеанса фильма
                - Из сервиса **Session Service** по полю **sessionId** объект типа **BookingRequest** переменной 
                **request** вызывается метод для получения объекта типа **SessionResponse**
                    - Если поле **available** объекта типа **SessionResponse** содержит значение **false**, то в ответе 
                    возвращается объект типа ApiErrorResponse с кодом 400
                - Из сервиса **Movie Service** по полю **movieId** объекта типа **SessionResponse** вызывается метод для 
                получения продолжительности фильма типа **Integer**
                    - Если текущая дата и время + продолжительность фильма больше время начала сеанса, то в ответе 
                    возвращается объект типа **ApiErrorResponse** с кодом 400
        - Выполняется проверка на обновленном статусе у бронирования
            - Если у бронирования теперь статус со значением **CANCELED**
                - В сервис **Session Service** отправляется запрос с идентификаторами мест записи бронирования сеансов 
                по изменению доступности мест на значение **true**
            - Иначе
                - Удаляются старые места в БД данного сервиса
                - В сервис **Session Service** отправляется запрос с идентификаторами старых мест записи бронирования 
                сеансов по изменению доступности мест на значение **true**
                - Создаются новые места в БД данного сервиса
                - В сервис **Session Service** отправляется запрос с идентификаторами новых мест записи бронирования
                  сеансов по изменению доступности мест на значение **false**
        - В БД выполняется обновление существующей записи о бронировании
        - Выполняется построение полного объекта типа **BookingResponse**, где для получения объектов типа
          **SessionResponse** необходимо обратиться к сервису **Session Service**
        - Объект типа **BookingResponse** отправляется в очередь 
            - Если в поле **userId** объекта типа **BookingRequest** из переменной **request** изменилось значение, 
            то отправляется в очередь для создания квитанции о бронировании 
            - Иначе отправляется в очередь для обновления квитанции о бронировании
        - В ответе возвращается объект типа **BookingResponse** с кодом 200
    - **PATCH /api/v1/bookings/{id}/status**
        - Приходит запрос с идентификатором бронирования в переменной **id** JSON в переменной **request**, где
          содержится объект типа **BookingStatusRequest**
        - Выполняется проверка электронной почты пользователя
            - Если электронная почта не подтверждена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 
            403
        - Выполняется проверка идентификатора пользователя в поле **userId** объект типа **BookingStatusRequest** 
        переменной **request**
            - Если идентификатор пользователя равен null или пользователь, отправивший запрос, имеет роль client, то 
            его идентификатор подставляется в переменную **userId** объекта типа **BookingStatusRequest** переменной 
            **request**
        - Объект типа **BookingRequest** из переменной **request** проходит валидацию полей
            - Если проверка не пройдена, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 400
        - В БД выполняется проверка на существование записи с переданным идентификатором бронирования из переменной **id**
            - Если запись не существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется проверка на существование записи с переданным идентификатором пользователя из переменной **id** 
        и идентификатором пользователя из поля **userId** объекта типа **BookingStatusRequest** переменной **request**
            - Если запись не существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется проверка на то, что у бронирования с идентификатором бронирования из переменной **id** не 
        установлен статус **CANCELED**
            - Если запись существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется проверка на то, что у бронирования с идентификатором бронирования из переменной **id** уже не 
        установлен такой же статус, какой передается в поле **bookingStatus** объекта типа **BookingStatusRequest** 
        переменной **request**
            - Если запись существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется поиск по идентификатору бронирования из переменной **id**
            - Если запись существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Происходит замена статуса
        - В БД обновляется статус бронирования у записи бронирования
        - Выполняется проверка на обновленном статусе у бронирования
            - Если обновленный статус равен CANCELED, то в сервис **Session Service** отправляется запрос с 
            идентификаторами мест записи бронирования сеансов по изменению доступности мест на значение **true**
        - Выполняется построение полного объекта типа **BookingResponse**, где для получения объектов типа
          **SessionResponse** необходимо обратиться к сервису **Session Service**
        - Объект типа **BookingResponse** отправляется в очередь для обновления статуса квитанции о бронировании
        - В ответе возвращается объект типа **BookingResponse** с кодом 200
    - **DELETE /api/v1/bookings/{id}**
        - Приходит запрос с идентификатором бронирования в переменной **id**
        - В БД выполняется поиск по идентификатору бронирования из переменной **id**
            - Если запись существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД происходит удаление записи по сущности
        - В сервис **Session Service** отправляется запрос с идентификаторами мест записи бронирования сеансов по 
        изменению доступности мест на значение **true**
        - Выполняется проверка на статус у удаленного бронирования
            - Если статус у удаленного бронирования не был равен **CANCELED**, то сообщение об удалении отправляется в 
            очередь для удаления квитанции о бронировании сеанса
    - **GET /api/v1/bookings/{id}/user?userId={userId}**
        - Приходит запрос с идентификатором бронирования в переменной **id** и идентификатором пользователя в 
        переменной **userId**
        - В БД выполняется проверка на существование записи о бронировании по идентификатору бронирования из 
        переменной **id** и идентификатору пользователя из переменной **userId**
        - В ответе возвращается объект типа **Boolean** и код 200

#### Фоновые задачи
##### Проверка бронирований
- Из очереди приходит идентификатор сеанса
- По этому идентификатору происходит проверка на существование бронирований по этому идентификатору сеанса
  - Если записей не найдено, то задача завершается
- Происходит получение всех записей о местах бронирования по идентификатору сеанса и статусу бронирования
  - Если записей не найдено, то задача завершается
- Происходит обновление статуса у бронирований по найденным записям о местах бронирования
- Отправляются идентификаторы мест сеанса в очередь сообщений, чтобы они стали доступными для новых бронирований

### Receipt Service
Сервис для работы с квитанциями о бронировании сеансов. Порт данного сервиса 8037

#### Краткое описание
1. **Квитанции**
   - **GET /api/v1/receipts/booking/{booking-id}** - Получение квитанции по идентификатору бронирования (Доступно для 
   пользователей с ролью admin, manager и client)
   - Остальные методы не имеют эндпоинтов и предназначены для работы с сообщениями из брокера сообщений 
   RabbitMQ - об этих методах далее в [логике](#логика-6) работы сервиса
2. **Swagger**
   - **GET /swagger-ui.html** - доступ к Swagger (Доступно для всех)

#### Логика
1. **Квитанции**
    - **GET /api/v1/receipts/booking/{booking-id}**
        - Приходит запрос с идентификатором бронирования в переменной **booking-id**
        - Выполняется проверка пользователя
            - Если пользователь, отправивший запрос, имеет роль **client**, то в сервис **Booking Service** отправляется 
            запрос с проверкой на то, существует ли бронирование у этого пользователя с переданным идентификатором или нет
                - Если пользователь не имеет бронирования, то в ответе возвращается объект типа **ApiErrorResponse** 
                с кодом 404
        - В БД выполняется поиск файла квитанции по переданному идентификатору бронирования из переменной **booking-id**
            - Если файл не найден
                - Из сервиса **Booking Service** по идентификатору бронирования запрашивается объект типа **BookingResponse**
                - Из сервиса **User Service** по идентификатору пользователя из поля **userId** объекта типа 
                **BookingResponse** запрашивается объект типа **UserResponse**
                - Выполняется проверка на то, что в бронировании у каждого места в поле **places** объекта типа 
                **BookingResponse** переменной **bookingResponse** должен быть один и тот же сеанс
                    - Если количество сеансов больше одного, то в ответе возвращается объект типа **ApiErrorResponse** 
                    с кодом 400
                    - Если сеанс не равен идентификатору самого сеанса из поля **session**, то в ответе возвращается 
                    - объект типа **ApiErrorResponse** с кодом 400
                - Из сервиса **Movie Service** по идентификатору фильма из поля **movieId** объекта типа **SessionResponse** 
                запрашивается объект типа **MovieResponse**
                - Создаётся PDF файл в байтовом представлении
                - В БД выполняется сохранение записи с этим файлом для бронирования с идентификатором из переменной 
                **booking-id**
                - В ответе возвращается PDF файл с кодом 200
            - Иначе
                - В ответе возвращается PDF файл с кодом 200
    - **Метод для ожидания сообщения по созданию квитанции**
        - Приходит сообщение с объектом типа **ReceiptRequest** в переменной **request**
        - В БД выполняется проверка на существование записи с идентификатором бронирования из поля **id** объекта типа 
        **Booking Response** из переменной **request** и идентификатором пользователя из поля **id** объекта типа 
        **UserResponse** из переменной **request**
            - Если запись существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 409
        - Выполняется проверка на то, что в бронировании у каждого места в поле **places** объекта типа
        **BookingResponse** из переменной **bookingResponse** должен быть один и тот же сеанс
          - Если количество сеансов больше одного, то в ответе возвращается объект типа **ApiErrorResponse**
          с кодом 400
          - Если сеанс не равен идентификатору самого сеанса из поля **session**, то в ответе возвращается
          объект типа **ApiErrorResponse** с кодом 400
        - Из сервиса **Movie Service** по идентификатору фильма из поля **movieId** объекта типа **SessionResponse**
          запрашивается объект типа **MovieResponse**
        - Создаётся PDF файл в байтовом представлении
        - В БД выполняется проверка на то, что запись с идентификатором бронирования из поля **id** объекта типа
          **Booking Response** из переменной **request**
            - Если запись существует, то в бд выполняется обновление идентификатора пользователя и файла у существующей 
            записи по идентификатору бронирования **id** объекта типа **Booking Response** из переменной **request**
            - Иначе в БД выполняется сохранение новой записи с идентификатором бронирования **id** объекта типа 
            **Booking Response** из переменной **request**
        - Создается объект типа **NotificationRequest** и отправляется в очередь для отправки квитанции и сообщении о 
        создании бронирования
    - **Метод для ожидания сообщения по обновлению квитанции**
        - Приходит сообщение с объектом типа **ReceiptRequest** в переменной **request**
        - В БД выполняется проверка на существование записи с идентификатором бронирования из поля **id** объекта типа 
        **BookingResponse**
            - Если записи не существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется проверка на то, что в бронировании у каждого места в поле **places** объекта типа
          **BookingResponse** из переменной **bookingResponse** должен быть один и тот же сеанс
            - Если количество сеансов больше одного, то в ответе возвращается объект типа **ApiErrorResponse**
              с кодом 400
            - Если сеанс не равен идентификатору самого сеанса из поля **session**, то в ответе возвращается
              объект типа **ApiErrorResponse** с кодом 400
        - Из сервиса **Movie Service** по идентификатору фильма из поля **movieId** объекта типа **SessionResponse**
          запрашивается объект типа **MovieResponse**
        - Создаётся PDF файл в байтовом представлении
        - В БД выполняется обновление записи с этим файлом для бронирования с идентификатором из поля **id** объекта
          типа **BookingResponse**
        - Создается объект типа **NotificationRequest** и отправляется в очередь для отправки квитанции и сообщении об
          обновлении бронирования
    - **Метод для ожидания сообщения по обновлению статуса квитанции**
        - Приходит сообщение с объектом типа **ReceiptRequest** в переменной **request**
        - В БД выполняется проверка на существование записи с идентификатором бронирования из поля **id** объекта типа
          **BookingResponse**
            - Если записи не существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - Выполняется проверка на то, что в бронировании у каждого места в поле **places** объекта типа
          **BookingResponse** из переменной **bookingResponse** должен быть один и тот же сеанс
            - Если количество сеансов больше одного, то в ответе возвращается объект типа **ApiErrorResponse**
              с кодом 400
            - Если сеанс не равен идентификатору самого сеанса из поля **session**, то в ответе возвращается
              объект типа **ApiErrorResponse** с кодом 400
        - Из сервиса **Movie Service** по идентификатору фильма из поля **movieId** объекта типа **SessionResponse**
          запрашивается объект типа **MovieResponse**
        - Создаётся PDF файл в байтовом представлении
        - В БД выполняется обновление записи с этим файлом для бронирования с идентификатором из поля **id** объекта
          типа **BookingResponse**
        - Создается объект типа **NotificationRequest** и отправляется в очередь для отправки квитанции и сообщении об
          обновлении статуса бронирования
    - **Метод для ожидания сообщения по удалению квитанции**
        - Приходит сообщение с объектом типа **NotificationDeleteRequest** в переменной **request**
        - В БД выполняется проверка на существование записи с идентификатором бронирования из поля **bookingId** объекта 
        типа **NotificationDeleteRequest**
            - Если записи не существует, то в ответе возвращается объект типа **ApiErrorResponse** с кодом 404
        - В БД выполняется удаление записи по идентификатору бронирования из поля **bookingId**
        - Объект типа **NotificationDeleteRequest** переменной **request** оправляется в очередь для отправки сообщения 
        об удалении квитанции 

#### Notification Service
Сервис для работы с уведомлениями. Порт данного сервиса 8038

#### Краткое описание
Все методы не имеют эндпоинтов и предназначены для работы с сообщениями из брокера сообщений
RabbitMQ - об этих методах далее в [логике](#логика-7) работы сервиса

#### Логика
- **Метод для ожидания сообщения по созданию квитанции**
    - Приходит сообщение с объектом типа **NotificationRequest** в переменной **request**
    - Формируется сообщение и отправляется на электронную почту (можно увидеть отправленное сообщение в 
    docker-контейнере maildev)
- **Метод для ожидания сообщения по обновлении квитанции**
    - Приходит сообщение с объектом типа **NotificationRequest** в переменной **request**
    - Формируется сообщение и отправляется на электронную почту (можно увидеть отправленное сообщение в
      docker-контейнере maildev)
- **Метод для ожидания сообщения по обновлению статуса квитанции**
    - Приходит сообщение с объектом типа **NotificationRequest** в переменной **request**
    - Формируется сообщение и отправляется на электронную почту (можно увидеть отправленное сообщение в
      docker-контейнере maildev)
- **Метод для ожидания сообщения по удалению квитанции**
    - Приходит сообщение с объектом типа **NotificationDeleteRequest** в переменной **request**
    - Формируется сообщение и отправляется на электронную почту (можно увидеть отправленное сообщение в
      docker-контейнере maildev)

#### Schedule Service
Сервис для работы с фоновыми задачами. Порт данного сервиса 8039

#### Краткое описание
Все методы не имеют эндпоинтов и предназначены для работы с сообщениями из брокера сообщений
RabbitMQ - об этих методах далее в [логике](#логика-8) работы сервиса

#### Логика
- **Метод для ожидания сообщения по созданию задачи о деактивации клиента, если он не подтвердил свою почту**
    - Приходит сообщение с объектом типа **TaskRequest** в переменной **request**
    - Создаётся задача, которая запускается один раз в заданное время
- **Задача для отправки сообщения о деактивации клиента, если он не подтвердил свою почту**
    - Из контекста **JobExecutionContext** у объекта типа **JobDetailImpl** берется поле name
    - Значение из поля name отправляется в сервис [**User Service**](#user-service) для выполнения фоновой задачи
    - Удаляется вызванная задача
- **Метод для ожидания сообщения по созданию задачи об удалении клиента, если у него деактивирован аккаунт**
    - Приходит сообщение с объектом типа **TaskRequest** в переменной **request**
    - Идёт проверка на то, что задача уже существует
      - Если задача уже существует, то дальнейшие действия прекращаются
    - Создается задача, которая выполняется по cron выражению
- **Задача для отправки сообщения об удалении клиента, если у него деактивирован аккаунт**
    - Создается объект типа **TaskResponse** с **Map<String, Object>**, где содержится константа состояния выполнения 
      действия по cron по ключу **userState**
    - Объект типа **TaskResponse** отправляется в сервис [**User Service**](#user-service) для выполнения фоновой задачи
- **Метод для ожидания сообщения по созданию задачи о проверке бронирований по идентификатору сеанса**
    - Приходит сообщение с объектом типа **TaskRequest** в переменной **request**
    - Идёт проверка на то, что **type** из **additionalProperties** в **request**
    равен **SESSION_START_UPDATE**
      - Если **type** равен **SESSION_START_UPDATE**, то задача удаляется
    - Создаётся задача, которая запускается один раз в заданное время
- **Задача для отправки сообщения о проверке бронирований по идентификатору сеанса**
    - Из контекста **JobExecutionContext** у объекта типа **JobDetailImpl** берется поле name
    - Значение из поля name отправляется в сервис [**Booking Service**](#booking-service) для выполнения фоновой задачи
    - Удаляется вызванная задача
- **Метод для ожидания сообщения по созданию задачи о завершении доступности сеанса**
    - Приходит сообщение с объектом типа **TaskRequest** в переменной **request**
    - Создаётся задача, которая запускается один раз в заданное время
- **Задача для отправки сообщения о проверке бронирований по идентификатору сеанса**
    - Из контекста **JobExecutionContext** у объекта типа **JobDetailImpl** берется поле name
    - Значение из поля name отправляется в сервис [**Session Service**](#session-service) для выполнения фоновой задачи
    - Удаляется вызванная задача
- **Метод для ожидания сообщения по удалению задач о проверке бронирований по идентификатору сеанса и о завершении 
доступности сеанса**
    - Приходит наименование задачи в переменной **name** типа String
    - Идёт проверка на то, что существует задача о проверке бронирований по идентификатору сеанса
      - Если существует задача, то она удаляется
    - Идёт проверка на то, что существует задача о завершении доступности сеанса
      - Если существует задача, то она удаляется
    

## Keycloak
Порт **Keycloak** равен 9180

### Роли

Список ролей: **admin**, **manager**, **client**

### Пользователи

Логин: **admin5876**<br>
Пароль: **1234**<br>
Роль: **admin**

Логин: **ivan5436**<br>
Пароль: **1234**<br>
Роль: **manager**

Логин: **dima1111**<br>
Пароль: **1234**<br>
Роль: **client**

Логин: **alex3865**<br>
Пароль: **1234**<br>
Роль: **client**

### Клиенты

- **cloud-service**
- **config-server**
- **gateway-client**
- **admin-server**
- **victoria-metrics**

### Админка
Данные для входа:

Логин: **admin**<br>
Пароль: **pass**


## Мониторинг

Мониторинг сервисов реализован с помощью **Grafana**, куда включаются **Victoria Metrics** как **Prometheus**, **Loki** 
и **Tempo**. Отдельно ресурсы подключать не нужно, они настроены с помощью конфигурации. Порт у **Grafana** 3000. Данные 
для входа в **Grafana**:

Логин: **admin**<br>
Пароль: **pass**

## Docker

Docker-контейнеры для работы сервисов данного мультимодульного проекта:
- **PostgreSQL** (В нескольких экземплярах для разных сервисов и для Keycloak)
- **Keycloak**
- **RabbitMQ**
- **MailDev**
- **Victoria Metrics**
- **Loki**
- **Tempo**
- **Grafana**